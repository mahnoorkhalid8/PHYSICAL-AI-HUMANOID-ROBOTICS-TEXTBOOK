---
id: ros2-architecture
title: ROS 2 Architecture for Humanoids
---

# ROS 2 Architecture for Humanoids

This section delves into the architectural principles of ROS 2 for humanoid robots.

## ROS 2 Core Concepts

ROS 2 (Robot Operating System 2) provides a flexible framework for writing robot software. It includes a collection of tools, libraries, and conventions that aim to simplify the task of creating complex and robust robot behavior across a wide variety of robot platforms.

### Key Architectural Components:

1. **Nodes**: Processes that perform computation
2. **Topics**: Named buses over which nodes exchange messages
3. **Services**: Synchronous request/response communication
4. **Actions**: Asynchronous goal-oriented communication
5. **Parameters**: Configuration values that can be changed at runtime

## ROS 2 Middleware and Communication

ROS 2 uses DDS (Data Distribution Service) as its underlying middleware, which provides:

- **Decentralized Architecture**: No central master node, improving robustness
- **Real-time Performance**: Deterministic communication for time-critical applications
- **Language Independence**: Support for multiple programming languages
- **Platform Portability**: Runs on various operating systems and hardware

### Quality of Service (QoS) Settings

For humanoid robots, QoS settings are crucial for reliable operation:

```python
from rclpy.qos import QoSProfile, QoSDurabilityPolicy, QoSReliabilityPolicy

# For critical control commands
control_qos = QoSProfile(
    depth=10,
    durability=QoSDurabilityPolicy.TRANSIENT_LOCAL,
    reliability=QoSReliabilityPolicy.RELIABLE
)

# For sensor data (e.g., IMU, camera feeds)
sensor_qos = QoSProfile(
    depth=5,
    durability=QoSDurabilityPolicy.VOLATILE,
    reliability=QoSReliabilityPolicy.BEST_EFFORT
)
```

## ROS 2 Python Node Example

Here's a simple ROS 2 Python node that publishes joint positions for a humanoid robot:

```python
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import JointState
from std_msgs.msg import Header
import math
import time

class HumanoidJointPublisher(Node):
    """
    A ROS 2 node that publishes joint states for a humanoid robot.
    This example demonstrates basic publisher functionality in ROS 2.
    """

    def __init__(self):
        super().__init__('humanoid_joint_publisher')

        # Create a publisher for joint states
        self.publisher_ = self.create_publisher(JointState, 'joint_states', 10)

        # Timer to publish messages at regular intervals
        timer_period = 0.1  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)

        # Initialize joint names for a simple humanoid
        self.joint_names = [
            'left_hip_joint', 'left_knee_joint', 'left_ankle_joint',
            'right_hip_joint', 'right_knee_joint', 'right_ankle_joint',
            'left_shoulder_joint', 'left_elbow_joint',
            'right_shoulder_joint', 'right_elbow_joint'
        ]

        self.i = 0
        self.get_logger().info('Humanoid Joint Publisher Node Started')

    def timer_callback(self):
        msg = JointState()
        msg.header = Header()
        msg.header.stamp = self.get_clock().now().to_msg()
        msg.header.frame_id = "base_link"

        msg.name = self.joint_names
        msg.position = []

        # Generate some example joint positions (oscillating for demonstration)
        for j, name in enumerate(self.joint_names):
            # Create oscillating joint positions for demonstration
            position = math.sin(self.i / 10.0 + j) * 0.5
            msg.position.append(position)

        self.publisher_.publish(msg)
        self.i += 1
        self.get_logger().debug(f'Publishing joint states: {msg.position}')


def main(args=None):
    rclpy.init(args=args)

    humanoid_publisher = HumanoidJointPublisher()

    try:
        rclpy.spin(humanoid_publisher)
    except KeyboardInterrupt:
        pass
    finally:
        humanoid_publisher.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

## Advanced ROS 2 Concepts for Humanoid Robotics

### Lifecycle Nodes
For humanoid robots that require more complex state management:

```python
from rclpy.lifecycle import LifecycleNode, LifecycleState, TransitionCallbackReturn
from rclpy.lifecycle import Publisher

class HumanoidLifecycleNode(LifecycleNode):
    def __init__(self):
        super().__init__('humanoid_lifecycle_node')
        self.pub = None

    def on_configure(self, state: LifecycleState) -> TransitionCallbackReturn:
        self.pub = self.create_publisher(JointState, 'joint_states', 10)
        self.get_logger().info('Lifecycle node configured')
        return TransitionCallbackReturn.SUCCESS

    def on_activate(self, state: LifecycleState) -> TransitionCallbackReturn:
        self.pub.on_activate()
        self.get_logger().info('Lifecycle node activated')
        return TransitionCallbackReturn.SUCCESS

    def on_deactivate(self, state: LifecycleState) -> TransitionCallbackReturn:
        self.pub.on_deactivate()
        self.get_logger().info('Lifecycle node deactivated')
        return TransitionCallbackReturn.SUCCESS

    def on_cleanup(self, state: LifecycleState) -> TransitionCallbackReturn:
        self.destroy_publisher(self.pub)
        self.pub = None
        self.get_logger().info('Lifecycle node cleaned up')
        return TransitionCallbackReturn.SUCCESS
```

## Running the Node

To run this node:

1. Make sure your ROS 2 environment is sourced:
   ```bash
   source /opt/ros/humble/setup.bash  # or your ROS 2 distribution
   ```

2. Save the code as `humanoid_joint_publisher.py` in your ROS 2 package

3. Make it executable:
   ```bash
   chmod +x humanoid_joint_publisher.py
   ```

4. Run the node:
   ```bash
   ros2 run your_package_name humanoid_joint_publisher.py
   ```

## ROS 2 Ecosystem for Humanoid Robots

The ROS 2 ecosystem provides several packages specifically useful for humanoid robotics:

- **ros2_control**: Hardware abstraction and controller management
- **moveit2**: Motion planning framework
- **navigation2**: Path planning and navigation stack
- **rviz2**: 3D visualization tool for robot data
- **rosbag2**: Data recording and playback for testing

## Cross-Module References

For more information about related topics, see:
- Module 1: ROS 2 Nodes, Topics, and Services for communication patterns
- Module 1: Bridging Python Agents with RCLPY for Python integration
- Module 1: URDF Robot Description for Humanoids for robot modeling
- Module 2: Gazebo Simulation Setup for simulation integration
- Module 2: URDF and SDF Formats for model integration
- Module 2: Physics and Sensor Simulation for environment modeling
- Module 2: Unity Visualization Setup for advanced rendering
- Module 3: Isaac SDK and Sim Overview for advanced simulation platforms
- Module 3: Perception and Manipulation for object interaction
- Module 3: Reinforcement Learning Control for adaptive behavior
- Module 3: Sim-to-Real Transfer for deployment considerations
- Module 4: GPT Integration for Conversational AI
- Module 4: Speech Recognition with Whisper for voice processing
- Module 4: Cognitive Planning for LLM-to-ROS translation
- Module 4: Capstone Project: Autonomous Humanoid for complete system integration

This example demonstrates the fundamental ROS 2 publisher pattern that would be used in a humanoid robot to broadcast joint positions to other nodes in the system.
